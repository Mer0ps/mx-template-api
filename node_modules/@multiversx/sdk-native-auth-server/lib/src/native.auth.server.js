"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.NativeAuthServer = void 0;
const axios_1 = require("axios");
const crypto = require("crypto");
const native_auth_invalid_block_hash_error_1 = require("./entities/errors/native.auth.invalid.block.hash.error");
const native_auth_invalid_signature_error_1 = require("./entities/errors/native.auth.invalid.signature.error");
const native_auth_token_expired_error_1 = require("./entities/errors/native.auth.token.expired.error");
const native_auth_validate_result_1 = require("./entities/native.auth.validate.result");
const native_auth_decoded_1 = require("./entities/native.auth.decoded");
const native_auth_origin_not_accepted_error_1 = require("./entities/errors/native.auth.origin.not.accepted.error");
const sdk_core_1 = require("@multiversx/sdk-core");
const native_auth_invalid_token_ttl_error_1 = require("./entities/errors/native.auth.invalid.token.ttl.error");
const native_auth_invalid_token_error_1 = require("./entities/errors/native.auth.invalid.token.error");
const native_auth_invalid_config_error_1 = require("./entities/errors/native.auth.invalid.config.error");
class NativeAuthServer {
    constructor(config) {
        this.config = config;
        this.DEFAULT_API_URL = "https://api.multiversx.com";
        this.MAX_EXPIRY_SECONDS = 86400;
        if (!config.apiUrl) {
            config.apiUrl = this.DEFAULT_API_URL;
        }
        if (!(config.maxExpirySeconds > 0 && config.maxExpirySeconds <= this.MAX_EXPIRY_SECONDS)) {
            throw new native_auth_invalid_config_error_1.NativeAuthInvalidConfigError(`maxExpirySeconds must be greater than 0 and cannot be greater than ${this.MAX_EXPIRY_SECONDS}`);
        }
        if (!Array.isArray(config.acceptedOrigins)) {
            throw new native_auth_invalid_config_error_1.NativeAuthInvalidConfigError('acceptedOrigins must be an array');
        }
        if (!config.acceptedOrigins || config.acceptedOrigins.length === 0) {
            throw new native_auth_invalid_config_error_1.NativeAuthInvalidConfigError('at least one value must be specified in the acceptedOrigins array');
        }
    }
    decode(accessToken) {
        const tokenComponents = accessToken.split('.');
        if (tokenComponents.length !== 3) {
            throw new native_auth_invalid_token_error_1.NativeAuthInvalidTokenError();
        }
        const [address, body, signature] = accessToken.split('.');
        const parsedAddress = this.decodeValue(address);
        const parsedBody = this.decodeValue(body);
        const bodyComponents = parsedBody.split('.');
        if (bodyComponents.length !== 4) {
            throw new native_auth_invalid_token_error_1.NativeAuthInvalidTokenError();
        }
        const [origin, blockHash, ttl, extraInfo] = bodyComponents;
        let parsedExtraInfo;
        try {
            parsedExtraInfo = JSON.parse(this.decodeValue(extraInfo));
        }
        catch (_a) {
            throw new native_auth_invalid_token_error_1.NativeAuthInvalidTokenError();
        }
        const parsedOrigin = this.decodeValue(origin);
        const result = new native_auth_decoded_1.NativeAuthDecoded({
            ttl: Number(ttl),
            origin: parsedOrigin,
            address: parsedAddress,
            extraInfo: parsedExtraInfo,
            signature,
            blockHash,
            body: parsedBody,
        });
        // if empty object, delete extraInfo ('e30' = encoded '{}')
        if (extraInfo === 'e30') {
            delete result.extraInfo;
        }
        return result;
    }
    validate(accessToken) {
        return __awaiter(this, void 0, void 0, function* () {
            const decoded = this.decode(accessToken);
            if (decoded.ttl > this.config.maxExpirySeconds) {
                throw new native_auth_invalid_token_ttl_error_1.NativeAuthInvalidTokenTtlError(decoded.ttl, this.config.maxExpirySeconds);
            }
            if (this.config.acceptedOrigins.length > 0 &&
                !this.config.acceptedOrigins.includes(decoded.origin) &&
                !this.config.acceptedOrigins.includes('https://' + decoded.origin)) {
                throw new native_auth_origin_not_accepted_error_1.NativeAuthOriginNotAcceptedError();
            }
            const blockTimestamp = yield this.getBlockTimestamp(decoded.blockHash);
            if (!blockTimestamp) {
                throw new native_auth_invalid_block_hash_error_1.NativeAuthInvalidBlockHashError();
            }
            const currentBlockTimestamp = yield this.getCurrentBlockTimestamp();
            const expires = blockTimestamp + decoded.ttl;
            const isTokenExpired = expires < currentBlockTimestamp;
            if (isTokenExpired) {
                throw new native_auth_token_expired_error_1.NativeAuthTokenExpiredError();
            }
            const address = new sdk_core_1.Address(decoded.address);
            const signatureBuffer = Buffer.from(decoded.signature, 'hex');
            const signedMessage = `${decoded.address}${decoded.body}`;
            let valid = this.verifySignature(address, signedMessage, signatureBuffer);
            if (!valid && !this.config.skipLegacyValidation) {
                const signedMessageLegacy = `${decoded.address}${decoded.body}{}`;
                valid = this.verifySignature(address, signedMessageLegacy, signatureBuffer);
            }
            if (!valid) {
                throw new native_auth_invalid_signature_error_1.NativeAuthInvalidSignatureError();
            }
            const result = new native_auth_validate_result_1.NativeAuthResult({
                issued: blockTimestamp,
                expires,
                origin: decoded.origin,
                address: decoded.address,
                extraInfo: decoded.extraInfo,
            });
            if (!decoded.extraInfo) {
                delete result.extraInfo;
            }
            return result;
        });
    }
    verifySignature(address, messageString, signature) {
        const cryptoPublicKey = crypto.createPublicKey({
            format: 'der',
            type: 'spki',
            key: this.toDER(address.pubkey()),
        });
        const signableMessage = new sdk_core_1.SignableMessage({
            address,
            message: Buffer.from(messageString, 'utf8'),
        });
        const cryptoMessage = Buffer.from(signableMessage.serializeForSigning().toString('hex'), "hex");
        return crypto.verify(null, cryptoMessage, cryptoPublicKey, signature);
    }
    get(url) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield axios_1.default.get(url, { headers: this.config.extraRequestHeaders });
            return response.data;
        });
    }
    getCurrentBlockTimestamp() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.config.cache) {
                const timestamp = yield this.config.cache.getValue('block:timestamp:latest');
                if (timestamp) {
                    return timestamp;
                }
            }
            const response = yield this.get(`${this.config.apiUrl}/blocks?size=1&fields=timestamp`);
            const timestamp = Number(response[0].timestamp);
            if (this.config.cache) {
                yield this.config.cache.setValue('block:timestamp:latest', timestamp, 6);
            }
            return timestamp;
        });
    }
    getBlockTimestamp(hash) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            if (this.config.cache) {
                const timestamp = yield this.config.cache.getValue(`block:timestamp:${hash}`);
                if (timestamp) {
                    return timestamp;
                }
            }
            try {
                const timestamp = yield this.get(`${this.config.apiUrl}/blocks/${hash}?extract=timestamp`);
                if (this.config.cache) {
                    yield this.config.cache.setValue(`block:timestamp:${hash}`, Number(timestamp), this.config.maxExpirySeconds);
                }
                return Number(timestamp);
            }
            catch (error) {
                if (axios_1.default.isAxiosError(error)) {
                    if (((_a = error.response) === null || _a === void 0 ? void 0 : _a.status) === 404) {
                        return undefined;
                    }
                }
                throw error;
            }
        });
    }
    decodeValue(str) {
        return Buffer.from(this.unescape(str), 'base64').toString('utf8');
    }
    unescape(str) {
        return str.replace(/-/g, "+").replace(/_/g, "\/");
    }
    toDER(key) {
        // Ed25519's OID
        const oid = Buffer.from([0x06, 0x03, 0x2B, 0x65, 0x70]);
        // Create a byte sequence containing the OID and key
        const elements = Buffer.concat([
            Buffer.concat([
                Buffer.from([0x30]),
                Buffer.from([oid.length]),
                oid,
            ]),
            Buffer.concat([
                Buffer.from([0x03]),
                Buffer.from([key.length + 1]),
                Buffer.from([0x00]),
                key,
            ]),
        ]);
        // Wrap up by creating a sequence of elements
        const der = Buffer.concat([
            Buffer.from([0x30]),
            Buffer.from([elements.length]),
            elements,
        ]);
        return der;
    }
}
exports.NativeAuthServer = NativeAuthServer;
